# Mohit Gupta

# Gardner-Floyds-Knob-Puzzle
# Giving the user an option to enter the dimensions of the block




import numpy as np
import random
import sys

answer = input("\n\nI'll print the solution first after this step.\n"
               "So don't let the main player see the solution.\n\n"
               "Do you want to give your own input? (type: own) \n\n OR "
               "\n\nDo you want computer to generate the maze? (type: computer)")


def row_column_generator(answer):
    """
    This function will generate the size of the maze.
    It asks user that do they want to enter their own size or do they
    want computer to generate the maze randomly.
    I have kept the numbers for random values in the range of 2 to 6 only otherwise
    it would become too big to be displayed on computer.

    :param answer: User's input if he wants the maze to be generated by him or by computer
    :return: returns row and column size
    """

    flag = True

    options = list(range(2,6))

    while flag:

        if answer == 'own':
            m = int(input(print("Enter the number of rows & columns:")))

            n = m

            flag = False

        elif answer == 'computer':

            m = int(random.choice(options))

            n = m

            flag = False

        else:
            print("Please enter, 'own' or 'computer' only.")

    return m,n














def organized_view(puzzle_structure):
    """
    This function will accept the numpy array and display it's contents in an organized way.
    :param puzzle_generator:
    :return:
    """

    for i in puzzle_structure:
        # I am using map function because if I'll use the " ".join(i) code directly, it'll give an error about that
        # it was supposed to get string but it got a list. Thus mapping the list element with the str data type.
        # This loop is to systematically display the initial iteration before randomizing the possible turns
        # from each turn.

        print("      ".join(map(str, i)))


    print("----------------------------------------------------------------\n\n")





def puzzle_structure_generator(m, n):
    """

    :param m: The desired rows input by the user
    :param n: The desired columns input by the user
    :return:  The final base structure of the puzzle
    """


    # Using list comprehension to generate the initial puzzle in the form of nested lists

    # Here "W" = West
    # Here "N" = North
    # Here "S" = South
    # Here "E" = East

    a = [["W", "N", "S", "E"] for i in range(m)]
    puzzle_structure = [a for i in range(n)]


    puzzle_structure = np.array(puzzle_structure)

    # As shown diagrammatically in the document submitted with this assignment,
    # a person cannot take a turn towards a wall.
    # Thus, for the turns adjacent to the below walls, I've to make the below elements zero.
    # For turns adjacent to:
    # West Wall, "W" == 0
    # North Wall, "N" == 0
    # South Wall, "S" == 0
    # East Wall, "E" == 0


    for i in range(n):

        # For North Wall, "N" = 0
        puzzle_structure[0][i][1] = 0

        # For South Wall, "S" = 0
        puzzle_structure[m-1][i][2] = 0


    for i in range(m):



        # For West Wall, "W" = 0
        puzzle_structure[i][0][0] = 0

        # For East Wall, "E" = 0
        puzzle_structure[i][n-1][3] = 0



    return puzzle_structure





def random_entry_point(puzzle_structure):
    """
    I will first extract the "first element" from the "first list element" from all the rows of first column.

    Similar procedure would be followed for the "last element" from the "last list element" from all the rows of the
    last column.

    Once I extract all the elements, I will randomly make one of the elements as " 1 " to signify it as the entry point
    or exit point.

    I will save the entry coordinate of the player.

    I also will code that you cannot exit from the entry point.

    :param puzzle_structure: Giving the resultant data structure from puzzle_structure_generator(m,n)
    :return: Returns two objects. One is the actual numpy array with the entry and exit points and
    two, the list which contains the solution coordinates.
    """


    entry_point = puzzle_structure[:, 0, 0]

    # I visited https://www.geeksforgeeks.org/python-select-random-value-from-a-list/ to find better method to randomly select an index.

    random_entry_index = random.randrange(len(entry_point))
    entry_point[random_entry_index] = 1


    exit_point = puzzle_structure[:, n-1, 3]
    random_exit_index = random.randrange(len(exit_point))
    exit_point[random_exit_index] = 1



    # Now I will replace the entry and exit points in the actual numpy array
    puzzle_structure[:, 0, 0] = entry_point
    puzzle_structure[:, n-1, 3] = exit_point


    # I will also save the entry and exit points in a list that will act as a recorder for correct list solutions match.
    # Also, I will not randomly change the direction restrictions of the solution coordinates as they should be fixed.


    solution_coordinate_sequence = [[random_entry_index, 0], [random_exit_index, n-1]]


    return puzzle_structure, list(solution_coordinate_sequence)




def solution_generator(solution_coordinate_sequence):
    """
    This function is particularly used to generate the solutions for the generated random puzzle.
    The coordinates are appended in sequence of the entry move to exit.
    If you want to view the solution of the puzzle, please
    uncomment the comments in Step 3


    :param solution_coordinate_sequence:
    :return: This returns the coordinates for the solution in the correct sequence.
    """


    coordinates = []

    entry_coordinate = solution_coordinate_sequence[0]
    exit_coordinate =  solution_coordinate_sequence[-1]


    for i in range(n):

        coordinates.append([entry_coordinate[0], i])



    if entry_coordinate[0] > exit_coordinate[0]:

        for i in reversed(range(exit_coordinate[0], entry_coordinate[0])):


            coordinates.append([ i ,n-1])

    if entry_coordinate[0] < exit_coordinate[0]:

        for i in range(entry_coordinate[0] + 1, exit_coordinate[0] + 1):

            coordinates.append([i, n-1])



    return coordinates




def random_direction_generator(puzzle_structure, solution_coordinate_sequence):
    """
    This function changes the possible directions from each turning point for the player.
    This is done so that player would be provided with randomized turning options on each
    directional turn.

    The ['W', 'N', 'S', 'E'] represents the directions where player can turn.
    If the output is like:
    [0, 'N', 0, 'E'] then the player can only turn North and East.

    [1, 'N', 'S', 0]: Here, one signifies the entry point.
    [0, 'N', 'S', 1]: Here, one signifies the exit point which is from the east side.

    :param puzzle_structure:
    :param solution_coordinate_sequence:
    :return: puzzle structure with randomized directions
    """


    p_structure = puzzle_structure
    solutions = solution_coordinate_sequence
    all_coordinates = []
    required_coordinates = []



    # Generating the possible coordinates for the m * n puzzle

    for i in range(m):

        for j in range(n):

            all_coordinates.append([i,j])



    # Removing the coordinates that are in the solutions so that I would not mistakenly block the solution direction.

    for i in all_coordinates:

        if i not in solutions:
            required_coordinates.append(i)


    for i in required_coordinates:


        for j in range(4):


            # Now I am randomly generating one possible number, either '1' or '0'.
            # I learnt the below one line of code from the below link:
            # https://www.geeksforgeeks.org/python-select-random-value-from-a-list/
            # I the number that I generated is '0' then I will replace the individual element in the direction list to '0'.


            a = np.random.randint(2, size=1)

            if a == 0:
                p_structure[i[0], i[1], j] = 0


    return p_structure



def game_board(m,n,puzzle_structure, entry_coordinate):
    """
    This function is made in order to properly display the visuals of the game.
    Once the game starts, the non-empty element signifies the directions where the player can move.
    Once he makes a move, the previous position gets replaced by 0 and new position
    reveals the possible directional moves from that particular position.

    I made rest of the moves visible as 0 because in pratical life, when you take turns in a town,
    you never know that what turns are allowed in the town in new implementations have been made.
    I hope that makes sense.




    :param m: number of rows already entered by the player
    :param n: number of columns already entered by the player
    :param puzzle_structure: final puzzle structure with different directional turning options
    :param entry_coordinate: coordinates from where the player is entering the maze
    :return: None
    """


    # Making a board that only contains zero
    # When I used the below code, I was facing error while replacing the player's position with the an array.
    # I faced an error here earlier here which is described in the comment 39 in the below link:
    # https://stackoverflow.com/questions/4674473/valueerror-setting-an-array-element-with-a-sequence
    # Thus I decided not to use numpy array in this case and generate a normal array


    # zero_board = np.full((m,n), ["0"])

    zero_board = []

    for i in range(m):

        # I am adding eight spaces around both the sides of zero so that it would look presentable while printing the table.
        zero_board.append(["        0        "] * n)

    prev_x_coo = entry_coordinate[0]
    prev_y_coo = entry_coordinate[1]

    curr_x_coo = entry_coordinate[0]
    curr_y_coo = entry_coordinate[1]



    zero_board[curr_x_coo][curr_y_coo] = puzzle_structure[curr_x_coo, curr_y_coo]

    print("\n\nYou can only move in the below shown directions and do not choose one or zero.\n")
    organized_view(zero_board)

    flag = True

    while True:
        try:
            while flag:

                move_by_player = input("\n\n Enter the letter for your move except one and zero or enter 'stop' :")
                move_by_player = move_by_player.lower()

                if move_by_player in ['w', 'n', 's', 'e']:

                    if move_by_player == 'w':

                        curr_y_coo = curr_y_coo -1

                    elif move_by_player == 'n':

                        curr_x_coo = curr_x_coo - 1

                    elif move_by_player == 's':

                        curr_x_coo = curr_x_coo + 1

                    elif move_by_player == 'e':

                        curr_y_coo = curr_y_coo + 1

                elif move_by_player == 'stop':

                    sys.exit("That was a great attempt. I hope you win next time.")


                else:
                    print("Please enter the directions only from ['w', 'n', 's', 'e']")

                zero_board[prev_x_coo][prev_y_coo] = "        0        "
                zero_board[curr_x_coo][curr_y_coo] = puzzle_structure[curr_x_coo, curr_y_coo]




                prev_x_coo = curr_x_coo
                prev_y_coo = curr_y_coo

                organized_view(zero_board)


                a = puzzle_structure[curr_x_coo, curr_y_coo]
                a = a[-1]

                # Please read the warnings in the below comments which compelled me to write the below code.
                # As numpy.str cannot be compared to any other non-numpy data type because of the disagreement
                # between the numpy and the native python, I tried the below code instead.
                # Here, I created a numpy array which contains the string "1" and not the value 1.
                # Thus, it will be stored as numpy.str_ type element.

                b = np.array(["1"])
                b = b[0]



                # I also received a warning over here which is mentioned below:
                # FutureWarning: elementwise comparison failed; returning scalar instead, but in the future will perform elementwise comparison
                # This warning is usually for numpy which also affects the matplotlib
                # In short, there is a disagreement between numpy and native python when comparing the strings to numpy's numeric types
                # https://stackoverflow.com/questions/40659212/futurewarning-elementwise-comparison-failed-returning-scalar-but-in-the-futur
                # If we use == or 'in' to compare a string/integer to numpy ndarray, they aren't compatible

                if a == b:

                    # I learnt about sys.exit in the below link:
                    # https: // www.hashbangcode.com / article / stopping - code - execution - python

                    sys.exit("Congratulations, you won the game.")




        except IndexError:

            curr_y_coo = prev_y_coo
            curr_x_coo = prev_x_coo
            zero_board[curr_x_coo][curr_y_coo] = "X"
            organized_view(zero_board)

    return None




# Step 0: Generating the size column and row size for the maze:

m, n = row_column_generator(answer)



# Step 1 : Generating the base structure of the puzzle



puzzle_structure1 = puzzle_structure_generator(m,n)

# In case if you search for the shape of the above generated puzzle when m * n = 3 * 3,
# the shape would be ( 3, 3, 4 ) as I have designed it to be a multidimensional array.
# Displaying the puzzle in an organized view:


# Please uncomment the below comment to see how the initial base puzzle looked like.
# organized_view(puzzle_structure1)



# Step 2:
# Generating random entry and exit points:

puzzle_structure2, solution_coordinate_sequence1 = random_entry_point(puzzle_structure1)


# Please uncomment the below comment to see how the second iteration of the puzzle looked like after
# removing the directions which runs into the wall.
# organized_view(puzzle_structure2)




# Step 3:
# Generating the correct coordinate sequence of puzzle solution after randomly generating the
# entry and exit points:


solution_coordinate_sequence2 = solution_generator(solution_coordinate_sequence1)


# Please uncomment the below comments to see how the solutions look like
# in sequential order.

# print("Below are the solution coordinates in sequence. \nIf any other sequence would be provided, you'll not reach the end point:")
# print(solution_coordinate_sequence)
# print("\n\n\n")




# Step 4:

# Now I will change the existing directions and generate random directions.
puzzle_structure3 = random_direction_generator(puzzle_structure2, solution_coordinate_sequence2)
print("This is the solution:")

organized_view(puzzle_structure3)

print("Don't let the player playing the game look at this solution.")


# Step 5:

entry_coordinate = solution_coordinate_sequence2[0]
exit_coordinate =  solution_coordinate_sequence2[-1]

# Initiating the display for the game
game_board(m,n, puzzle_structure3, entry_coordinate)














